#import "libs/rsj-conf/lib.typ": rsj-conf
#show: rsj-conf.with(
  title: [人工知能レポート], 
  authors: [森田　知颯（03240454）],
  bibliography: bibliography("refs.yml", full: false)
)

#import "@preview/sourcerer:0.2.1": code
#show link: underline
#import "@preview/codelst:2.0.1": sourcecode

課題は、第四問を選択した。
= (1)3x3の1のみ騎士がいるパズル
まず最初に、問1の最短の解法はほぼ自明であるため、解答を@tab:q1answer に示す。盤面が3x3の場合は、ナイトがどの位置にいる場合でも次の手の候補が必ず2つしかなく、1手目を除いて、一方の手は今自分がやってきたマスへ戻る手になるため、正解の形になるまでの手は1本道になる。最初に1と9を入れ替えると、4手（最初の手番を含めて5つの盤面）で目的の形になる。
#figure(
    placement: bottom,
    caption: [問1の最短解法],
    
    grid(
        columns: 5,
        gutter: 1cm,
        [#table(
            columns: 3,
            
            [8], [2], [4],
            [9], [5], [6],
            [7], [3], [1]
        )],
        [#table(
            columns: 3,
            
            [8], [2], [4],
            [1], [5], [6],
            [7], [3], [9]
        )],
        [#table(
            columns: 3,
            
            [8], [2], [1],
            [4], [5], [6],
            [7], [3], [9]
        )],
        [#table(
            columns: 3,
            
            [8], [2], [3],
            [4], [5], [6],
            [7], [1], [9]
        )],
        [#table(
            columns: 3,
            
            [1], [2], [3],
            [4], [5], [6],
            [7], [8], [9]
        )],
        

    )
)<tab:q1answer>

== 深さ優先探索
コードはknight3x3D.pyに示してある。結果は、最初に1と9を入れ替えるか、1と2を入れ替えるかで結果が変わる。深さ優先であるため、最初の手を打つと一本道で探索済みのを避けて全てを探索するか、正解に辿り着くまで探索する。1と9を入れ替えると、すぐに正解に辿り着くが、1と2を入れ替えると、正解に着くまで時間がかかる。

1と9を入れ替える場合は最短の5種類の盤面の探索で4手で解に辿り着くが、1と2を入れ替えてしまうと、53種類の盤面の探索で52手で解に辿り着く。
\ \
== 広さ優先探索
コードはknight3x3Bに示してある。1と9を入れ替えた場合と1と2を入れ替えた場合、どちらも均等に探索していく。1と9を入れ替えた場合、深さ4で正解に辿り着くため、1と2で入れ替えた場合の深さ3の盤面の探索も必ず行われる。結果的に深さ優先探索の1と9を入れ替えた場合よりも少し手数が多く、9種類の盤面走査で正解に辿り着く。
\ \
== A\*探索
コードはknight3x3A.pyに示してある。ヒューリスティック関数としては、各マスが目的の盤面のマスと異なる個数をそのまま定義している。また、深さをそのままコストとしている。この場合、1と2を入れ替える場合と1と9を入れ替える場合の評価を比較していることになる。1と2を入れ替える場合、元々正しい位置にあった2を正しくない位置に置くためになる一方で、1と9を入れ替える場合、9を正しい位置に置くことになり、コスト関数が小さくなる1と9を入れ替える手を最初に選んでいる。その先の手は、1と2を入れ替える場合よりもコスト関数が小さくなるので、優先的に探索されて、この場合も最短の4手で計5種類の盤面の探索で済む。


= (2)4x4の1のみ騎士がいるパズル
4x4のパズルになると、盤面の探索はより複雑になる。1が四隅のマスにある場合は2手の候補があり、端のマスは3手、真ん中の4マスは、4手の候補がある。解法の例を@tab:q2answer に示す。特徴としては、最初に2を正しい位置にもっていくように動かすのではなく、1と9を入れ替えるほうが結果的に早く解にたどり着くという点である。
#figure(
    placement: top,
    caption: [問1の解法例（左から右、左上が初期状態）],
    
    grid(
        columns: 6,
        gutter: 1cm,
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 1 and y == 0 or x == 3 and y == 1){
                return rgb("ccccff")
            },
            [10], [1], [12],[4],
            [5], [13], [7],[9],
            [15],[3], [2], [6],
            [11],[14],[8],[16]
        )],
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 2 and y == 3 or x == 3 and y == 1){
                return rgb("ccccff")
            },
            [10], [9], [12],[4],
            [5], [13], [7],[1],
            [15],[3], [2], [6],
            [11],[14],[8],[16]
        )],
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 2 and y == 3 or x == 0 and y == 2){
                return rgb("ccccff")
            },
            [10], [9], [12],[4],
            [5], [13], [7],[8],
            [15],[3], [2], [6],
            [11],[14],[1],[16]
        )],
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 1 and y == 0 or x == 0 and y == 2){
                return rgb("ccccff")
            },
            [10], [9], [12],[4],
            [5], [13], [7],[8],
            [1],[3], [2], [6],
            [11],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 1 and y == 0 or x == 2 and y == 2){
                return rgb("ccccff")
            },
            [10], [1], [12],[4],
            [5], [13], [7],[8],
            [9],[3], [2], [6],
            [11],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 0 and y == 3 or x == 2 and y == 2){
                return rgb("ccccff")
            },
            [10], [2], [12],[4],
            [5], [13], [7],[8],
            [9],[3], [1], [6],
            [11],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x, y) =>
            if (x == 0 and y == 3 or x == 1 and y == 1){
                return rgb("ccccff")
            },
            [10], [2], [12],[4],
            [5], [13], [7],[8],
            [9],[3], [11], [6],
            [1],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x, y) =>
            if (x == 3 and y == 2 or x == 1 and y == 1){
                return rgb("ccccff")
            },
            [10], [2], [12],[4],
            [5], [1], [7],[8],
            [9],[3], [11], [6],
            [13],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x, y) =>
            if (x == 3 and y == 2 or x == 2 and y == 0){
                return rgb("ccccff")
            },
            [10], [2], [12],[4],
            [5], [6], [7],[8],
            [9],[3], [11], [1],
            [13],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x, y) =>
            if (x == 1 and y == 2 or x == 2 and y == 0){
                return rgb("ccccff")
            },
            [10], [2], [1],[4],
            [5], [6], [7],[8],
            [9],[3], [11], [12],
            [13],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            fill: (x, y) =>
            if (x == 1 and y == 2 or x == 0 and y == 0){
                return rgb("ccccff")
            },
            [10], [2], [3],[4],
            [5], [6], [7],[8],
            [9],[1], [11], [12],
            [13],[14],[15],[16]
        )],
        [#table(
            columns: 4,
            
            [1], [2], [3],[4],
            [5], [6], [7],[8],
            [9],[10], [11], [12],
            [13],[14],[15],[16]
        )],
        

    )
)<tab:q2answer>
== 深さ優先探索
コードはknight4x4D.pyに示す。可能な手としては、指数的に増加していき、深さとしてもかなり深いため、単純にスタックで探索すると、本来深さ11で解ける(2)のパズルも10000を超える深さに潜っていってしまい、探索にはかなりの時間がかかってしまう。そのため、教科書@ai に示すように、深さの上限を決めて、見つからなかった場合その上限を増やしていくという方法を採用すると、深さ11の@tab:q2answer の解法を見つけることができた。
== 広さ優先探索
コードはknight4x4B.pyに示す。深さ11に至るまでにある程度の時間はかかるものの、特に工夫することなく、キューで探索をすれば深さ11の@tab:q2answer の解を見つけることができた。
\ \
== A\*探索
コードはknight4x4A.pyに示す。ヒューリスティック関数は3x3の時と変わらず、どれだけ正解の解から離れているかによって定義し、深さが1増えるごとにコストが1増えるようにした。他二つの手法を比較すると、深さ11の@tab:q2answer の解をかなり速く見つけることができた。
== 比較
@fig:compare にそれぞれの探索を用いた時の盤面の総探索数を示す。深さ優先探索においては、深さ制限を4とした場合が最も効率よく解を見つけることができ、その場合に限り広さ優先探索よりも効率が良い。一方で、それ以外の制限の場合は、10000を超える盤面の探索が必要だった。広さ優先探索と比較して制限2, 3の場合は1.7倍ほどの探索が必要で、制限5の場合は、さらに多くの探索が必要になった。

A\*探索はわずか25の盤面のみで、広さ優先探索と比較しても$1/300$以下の探索で解にたどり着けたことがわかる。直感的に、正解と異なるマスを数えるヒューリスティック関数でも愚直な探索に比べるとかなり効率よく解を見つけることができる。
#figure(
    placement: top,
    caption: [各探索の探索数],
    image("figs/4x4.png")
)<fig:compare>
= (3)任意の4x4の任意の騎士を動かすパズル
ナイトが移動できる位置関係にいるマス同士を交換して所望の盤面にするというように問題を解釈した。つまり、横に2マス縦に1マスずれたマスあるいは横に1マス、縦に2マスずれたマスと数字を交換することにより解を目指す、より自由度の高いパズルとして解釈した。

このとき、深さ1ですらかなりの盤面の候補があり、さらに深くなればそれが指数的に増加する。また解も(2)と比べても完全にランダムに並べ替えたものを初期状態とすると解がある深さも深くなっているのが特徴である。
== 深さ優先探索・広さ優先探索
コードはそれぞれknight4x4D_arbi.pyとknight4x4B_arbi.pyに示してある。
深さ1桁の探索ですら、現実的な計算量でなかったので、解を見つけるのはなかなか難しく、検証もできなかった。
== A\*探索
=== ヒューリスティック関数を目的の盤面と異なるマスの数とした場合
(2)と同様にヒューリスティック関数を正解の盤面と異なるマスの数とした場合を考える。コードはknight4x4A_arbi.pyに示してある。このヒューリスティック関数を以下H1と呼称する。また、深さに対するコストは0.1とした。この場合は、現実的な時間で解を見つけることができる。しかし、大抵の解は深さ30程度にあるのに対し、探索はおおむね100以上の盤面を探索をしたのちに解を見つけているため、ヒューリスティック関数の改善ができる見込みがある。
=== 距離の定義
新しいヒューリスティック関数を考えるために、このパズル特有のルールを軸にどれだけ正解の盤面からずれているかについての定義を見直してみる。

@tab:explain1 に示すようにSのマスからGのマスに移動したいとき、右に2マス、下に1マスずれているところに動かしたい。このとき、1手で動かせるため距離は1である定義する。
@tab:explain2 に示すように右に1マス、下に1マスずれているところに動かしたい場合は、一度左に1マス、下に2マス動かして、それからGのマスに移動するため、距離は2であると定義する。

同様に、他の位置関係について距離を定義することができる。その時の距離を@tab:distance に示す。このパズルのルールに基づいて解の距離を定義しているので、より解への距離を正確に表すことができていると考えられる。
#figure(
    placement: bottom,
    caption: [横に2マス、縦に1マスずれている場合],
    
    grid(
        columns: 2,
        gutter: 1cm,
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 1 and y == 0 or x == 3 and y == 1){
                return rgb("ccccff")
            },
            [　], [S], [　],[　],
            [　], [　], [　],[G],
            [　],[　], [　], [　],
            [　],[　],[　],[　]
        )],
    )
)<tab:explain1>
#figure(
    placement: bottom,
    caption: [横に2マス、縦に1マスずれている場合],
    
    grid(
        columns: 2,
        gutter: 1cm,
        [#table(
            columns: 4,
            fill: (x,y) =>
            if (x == 1 and y == 0 or x == 2 and y == 1){
                return rgb("ccccff")
            },
            [　], [S], [　],[　],
            [　], [　], [G],[　],
            [　],[　], [　], [　],
            [　],[　],[　],[　]
        )],
    )
)<tab:explain2>
#figure(
    placement: bottom,
    caption: [距離の定義],
    table(
        columns: 3,
        stroke: none,
        table.header(
        [縦],
        [縦],
        [距離],
        ),
        table.hline(),
        [0], [0], [0],
        [1], [0], [3],
        [1],[1],[2],
        [2],[0],[2],
        [2],[1],[1],
        [2],[2],[4],
        [3],[0],[3],
        [3],[1],[2],
        [3],[2],[3],
        [3],[3],[2]
    )
)<tab:distance>
=== 距離に基づいたヒューリスティック関数
純粋に目的の盤面と比較した各マスの距離の和によってヒューリスティック関数を定義したものをknight4x4A_arbi2.pyに示してある。このヒューリスティック関数を以下H2と呼称する。H1とH2の探索数の比較を@fig:compare2 に示す。各々で50問解かせて、その探索数の平均をとった。エラーバーは平均の1σの範囲を示している。H2の方がH1よりも探索数が少なく、より効率的に解を見つけることができるとわかる。
#figure(
    placement: top,
    caption: [H1とH2の探索数の平均],
    image("figs/4x4_arbi.png")
)<fig:compare2>
\ \ \ 
=== さらに良いヒューリスティック関数の探求のための進化計算
H2では、全てのマスにおける距離の和としてヒューリスティック関数を定義したが、距離ごとにヒューリスティック関数に足す値を変えるという方法も考えられる。つまり、距離1のとき、その1をそのまま足すのではなく、1.5を足したり、2を足したり、距離によって実数を返す関数を定義して、それらの和をヒューリスティック関数とするということである。

ついでに深さが1増えるごとにいくらコストを増やすかについてのパラメータも考えるようにする。よって、距離は0から4の5段階あるので、それと合わせて6つのパラメータを考えればよい。
このパラメーターを進化計算を用いて、最適なこのパズルを解く上での最適なパラメータを模索する。

進化計算を用いたパラメータを最適化を試みるコードをknight4x4A_arbi_ga.pyに示す。1世代あたり30個体生成し、その中から上位15体を残して、15体のパラメータをそのままシャッフルした個体を15体残し、残り15体を上位15体から重複を許してランダムで15体選び、パラメータにランダムな値を足したり引いたりした個体とする。これを27世代繰り返した（当初は30世代の予定だったが、十分速く解けるようになったと判断して27世代目で停止した）。なお、個体の順位は30問解かせたときの探索数の平均が小さいほど上位とする。最終的に最も探索数が少なかった個体のパラメータを採用し、H3と呼称する。

#figure(
    placement: bottom,
    caption: [最適なパラメータ],
    table(
        columns: 6,
        table.header(
        [距離0], [距離1],[距離2],[距離3],[距離4],[深さコスト],
        ),
        table.hline(),
        [-1.093],[0.120],[2.609],[3.539],[4.592],[-0.879],
    )
)<tab:best>
#figure(
    placement: top,
    caption: [H2とH3の探索数の平均],
    image("figs/4x4_compare3.png")
)<fig:compare3>

結果として、最も探索数が少なかった個体のパラメータを@tab:best に示す。合っているマスがある場合はコストを下げ、さらに深く探索するごとにコストを減らすというパラメータに落ち着いた。
では、このH3とH2を同様に探索数で比較してみる。50問ランダムな問題を解かせたときの探索数の平均を@fig:compare3 に示す。エラーバーは同様に平均の1σの範囲を表している。H3はH2と比べて、探索数を約61%削減することができた。

=== 遺伝の様子

#figure(
    placement: top,
    caption: [世代ごとの探索数の推移],
    image("figs/4x4ga.png")
)<fig:gene>

@fig:gene は進化計算によってどれだけ探索数が減少したかを示している。青色の線が最も探索数の平均が少なかった個体で、橙色の線が2番目に探索数の平均が少なかった個体を示している。なおH3で採用した個体は17世代目で得た。

@fig:gene からわかるように、最初の数世代は依然として探索数が大きいが10世代目以降は探索数は30未満となり、安定している。ランダムで出題されるパズルには多少難易度もあり、最小何手で解けるかもランダムであり、それによって誤差が生じ必ずしも単調減少しているわけではないが、10世代ほどで、ほぼ最適な個体が得られている見て良い。
\ \ \
== 展望
進化計算を用いて、単純な距離のヒューリスティック関数を超えて、距離によってどのようにヒューリスティック関数を定義するかを最適化することができた。さらなる最適化としてのアイデアは、深さによってコストをどのように増やすかをパラメータとして変えることが考えられる。
今回は、どの深さであっても、深さが1増えるごとにコスト関数がどれだけ変化するかを求めたが、深さによって変化するようにパラメータを設定することで、より効率的に解を見つけることができる可能性がある。

解はおおよそ深さ30程度であるため、直感的には、深さが30を超えるまではコストを増やさず、それを超えると、コストが大きくなっていくというようにすれば良いと予想できる。

= ファイルについて
本文でも触れたファイルがあるが、実験に用いた書いたコードや得られたデータなどの添付したファイルについてここでは説明する。

・knight3x3D.py (1)を解くための深さ優先探索のコード

・knight3x3B.py (1)を解くための広さ優先探索のコード

・knight3x3A.py (1)を解くためのA\*探索のコード

・knight4x4D.py (2)を解くための深さ優先探索のコード

・knight4x4B.py (2)を解くための広さ優先探索のコード

・knight4x4A.py (2)を解くためのA\*探索のコード

・knight4x4D_arbi.py (3)を解くための深さ優先探索のコード(基本解けない)

・knight4x4B_arbi.py (3)を解くための広さ優先探索のコード(基本解けない)

・knight4x4A_arbi.py (3)を解くためのA\*探索のコードでH1

・knight4x4A_arbi.txt knight4x4A_arbi.pyの実行結果

・knight4x4A_arbi2.py (3)を解くためのA\*探索のコードでH2

・knight4x4A_arbi2.txt knight4x4A_arbi2.pyの実行結果

・knight4x4A_arbi_ga.py (3)を解くためのA\*探索のコードでH3を求めるもの（30世代回すと5時間ほどかかる）

・knight4x4A_arbi_ga.csv knight4x4A_arbi_ga.pyの実行結果

・knight4x4A_arbi4.py (3)を解くためのA\*探索のコードでH3

・knight4x4A_arbi4.txt knight4x4A_arbi4.pyの実行結果

pythonファイルはpython3の標準モジュールで実行可能なため、前提となる環境構築はpython3のインストールのみである。また、そのまま実行してしまうと、特にtxtファイルが上書きされてしまう可能性があるので、注意されたい。


